% Загрузка данных из файла .mat
load('/Users/alexandrpylayev/Documents/MATLAB/Datafocheckforecasts.mat');

% Получение уникальных данных из столбца YahooFinanceTicker
uniqueData = unique(DATAforcheckingForecasts.YahooFinanceTicker);

% Создание новой таблицы с одним столбцом UniqueData
TickerNames = table(uniqueData, 'VariableNames', {'TickerName'});

% Получение количества строк в таблице
numRowsTickers = size(TickerNames, 1);

%%
% Цикл while для поочередного доступа к данным
i = 1;
while i <= numRowsTickers
    value = DATAforcheckingForecasts.YahooFinanceTicker(i);
    fprintf('Значение в строке %d: %d\n', i, value);
    %symbol = "BMY";
    symbol = TickerNames.TickerName(i);
    disp(symbol);
    symbol = char(symbol);
    file_path = ['/Users/alexandrpylayev/Documents/MATLAB/Dataforcheck/temp_data',symbol,'.csv'];
    disp(file_path)
    
    % Импорт таблицы из файла .csv
    TableForecasts = readtable(file_path, 'PreserveVariableNames', true);
    file_path2 = ['/Users/alexandrpylayev/Documents/MATLAB/Dataforcheck/temp_data2',symbol,'.csv'];
    disp(file_path2)
    
    % Импорт таблицы из файла .csv
    TablefromYahoo = readtable(file_path2, 'PreserveVariableNames', true);
    try
        if isempty(TablefromYahoo)
            disp('Таблица пустая. Процесс будет продолжен без обработки таблицы.');
        else
            disp('Таблица не пустая.');
            
            % Получение количества строк в таблице
            numRowsDates = size(TableForecasts, 1);
            
            % Добавляем пустой столбец с названием "NewColumn" (предполагаем, что тип данных столбца — double)
            TableForecasts.NewColumn1 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn2 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn3 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn4 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn5 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn6 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn7 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn8 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn9 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn10 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn11 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn12 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn13 = zeros(numRowsDates, 1);
            TableForecasts.NewColumn14 = zeros(numRowsDates, 1);
            %
            TableForecasts.NewColumn1(:) = NaN;
            TableForecasts.NewColumn2(:) = NaN;
            TableForecasts.NewColumn3(:) = NaN;
            TableForecasts.NewColumn4(:) = NaN;
            TableForecasts.NewColumn5(:) = NaN;
            TableForecasts.NewColumn6(:) = NaN;
            TableForecasts.NewColumn7(:) = NaN;
            TableForecasts.NewColumn8(:) = NaN;
            TableForecasts.NewColumn9(:) = NaN;
            TableForecasts.NewColumn10(:) = NaN;
            TableForecasts.NewColumn11(:) = NaN;
            TableForecasts.NewColumn12(:) = NaN;
            TableForecasts.NewColumn13(:) = NaN;
            TableForecasts.NewColumn14(:) = NaN;
            % Переименовываем добавленный столбец
            TableForecasts.Properties.VariableNames{17} = 'StatusOpenOrder';
            TableForecasts.Properties.VariableNames{18} = 'RuleOpen';
            TableForecasts.Properties.VariableNames{19} = 'RuleHigh';
            TableForecasts.Properties.VariableNames{20} = 'RuleLow';
            TableForecasts.Properties.VariableNames{21} = 'StatusTakeProfit';
            TableForecasts.Properties.VariableNames{22} = 'DateTakeProfit';
            TableForecasts.Properties.VariableNames{23} = 'IndicatorTakeProfit';
            TableForecasts.Properties.VariableNames{24} = 'StatusStopLoss';
            TableForecasts.Properties.VariableNames{25} = 'DateStopLoss';
            TableForecasts.Properties.VariableNames{26} = 'MaxinBuy';
            TableForecasts.Properties.VariableNames{27} = 'DateMax';
            TableForecasts.Properties.VariableNames{28} = 'MinSell';
            TableForecasts.Properties.VariableNames{29} = 'DateMin';
            TableForecasts.Properties.VariableNames{30} = 'ForecastGap';
            
            % num to datetime
            TableForecasts.DateTakeProfit = datetime(TableForecasts.DateTakeProfit, 'ConvertFrom', 'datenum');
            TableForecasts.DateStopLoss = datetime(TableForecasts.DateStopLoss, 'ConvertFrom', 'datenum');
            TableForecasts.DateMax = datetime(TableForecasts.DateMax, 'ConvertFrom', 'datenum');
            TableForecasts.DateMin = datetime(TableForecasts.DateMin, 'ConvertFrom', 'datenum');
            TableForecasts.DateTakeProfit.Format = 'yyyy-MM-dd';
            TableForecasts.DateStopLoss.Format = 'yyyy-MM-dd';
            TableForecasts.TerminateDate.Format = 'yyyy-MM-dd';
            TableForecasts.DateMax.Format = 'yyyy-MM-dd';
            TableForecasts.DateMin.Format = 'yyyy-MM-dd';
            
            TableForecasts.IndicatorTakeProfit = TableForecasts.Indicator; % Простое присваивание
            
            % Цикл для обработки данных по каждой строке
            a = 1;
            while a <= numRowsDates
                
                % Получение данных из ячейки в таблице
                OpenOrderDateValue = TableForecasts{a, 'OpenOrderDate'}; % Получение значения первой ячейки столбца 'OpenOrderDate'
                disp('Прогноза на Дату')
                disp(OpenOrderDateValue)
                BPriceValue = TableForecasts{a, 'BPrice'}; % Получение значения второй ячейки столбца 'BPrice'
                StopLossValue = TableForecasts{a, 'StopLoss'}; % Получение значения второй ячейки столбца 'StopLoss'
                EffectiveTakeProfitPriceValue = TableForecasts{a, 'EffectiveTakeProfitPrice'}; % Получение значения второй ячейки столбца 'EffectiveTakeProfitPrice'
                OrderTypeValue = TableForecasts{a, 'OrderType'}; % Получение значения второй ячейки столбца 'OrderType'
                IndicatorValue = TableForecasts{a, 'Indicator'}; % Получение значения второй ячейки столбца 'Indicator'
                TerminateOrderValue = TableForecasts{a, 'TerminateOrder'}; % Получение значения второй ячейки столбца 'TerminateOrder'
                TerminateDateValue = TableForecasts{a, 'TerminateDate'}; % Получение значения второй ячейки столбца 'TerminateDate'
                TerminateIndicatorValue = TableForecasts{a, 'TerminateIndicator'}; % Получение значения второй ячейки столбца 'TerminateIndicator'
                logicalIndex = TablefromYahoo.Date >= OpenOrderDateValue;
                
                % Извлечение совпадающих данных
                isNewerDates = TablefromYahoo(logicalIndex, :);
                disp(['Ticker_',symbol])
                disp('Тэйкпрофит')
                disp(EffectiveTakeProfitPriceValue)
                
                if strcmp(OrderTypeValue, 'buy')
                    
                    % Ваш код, который будет выполнен, если
                    % OrderTypeValue равно 'buy' проверяем условие
                    % открытия, чтобы цена открытия не выходили за
                    % пределы стоплоса и прошло через цена BPrice
                    disp('Сделка Buy')
                    RuleOpen = isNewerDates{1, 'Open'};
                    RuleLow = isNewerDates{1, 'Low'};
                    RuleHigh = isNewerDates{1, 'High'};
                    
                    if BPriceValue < RuleLow % ищем ГЭП
                        ForecastGap = 1;
                        LocalHighIndex = find(isNewerDates.Date >= OpenOrderDateValue);
                        LocalHigh = isNewerDates.High(LocalHighIndex);
                        maxLocalHigh = max(LocalHigh);
                        maxHigh = maxLocalHigh;
                        [rowIndex, ~] = find(isNewerDates.High == maxLocalHigh);
                        LocalHighDate = isNewerDates(rowIndex, :);
                        maxRow = LocalHighDate(1, :);
%                         if isempty(maxHigh)
%                             maxHigh = NaN;
%                             maxRow.Date = NaT;
%                         end
                        TableForecasts{a, 'MaxinBuy'} = maxHigh;
                        TableForecasts{a, 'DateMax'} = maxRow.Date;
                    else
                        ForecastGap = NaN;
                        TableForecasts{a, 'MinSell'} = NaN;
                        TableForecasts{a, 'DateMin'} = NaT;
                        TableForecasts{a, 'MaxinBuy'} = NaN;
                        TableForecasts{a, 'DateMax'} = NaT;
                    end
                    
                    RuleOpenIndex = RuleOpen <= StopLossValue | RuleHigh < BPriceValue | BPriceValue < RuleLow;
                    
                    if any(RuleOpenIndex)
                        % Хотя бы одно из условий выполнилось, то
                        % ничего непроисходит
                        StatusOpen = NaN;
                        disp('open price ниже стоплосса  или(и) не соответствует другим условиям -  сделка не открывается ');
                    else
                        % Ни одно из условий не выполнилось
                        disp('open price не ниже stopplossa и минимум не выше цены входа ');
                        StatusOpen = 1;
                        HighIndex = isNewerDates.High >= EffectiveTakeProfitPriceValue & OpenOrderDateValue <= isNewerDates.Date;
                        High = isNewerDates(HighIndex, :);%тэйк профит
                        StopIndex = isNewerDates.Low <= StopLossValue & OpenOrderDateValue <= isNewerDates.Date;
                        Stoploss = isNewerDates(StopIndex, :);%стоп лосс
                        
                        if isempty(High)
                            disp('значение максимума выше или равное Тэйкпрофита - пусто, значит бумага больше не росла и(или) был StopLoss или Terminate или еще открыта');
                            
                            % Сортировка таблицы по столбцу "Date"
                            if isempty(Stoploss)
                                disp('значение стопа пусто ищем локальный максимум');
                                LocalHighIndex = find(isNewerDates.Date >= OpenOrderDateValue);
                                LocalHigh = isNewerDates.High(LocalHighIndex);
                                maxLocalHigh = max(LocalHigh);
                                maxHigh = maxLocalHigh;
                                [rowIndex, ~] = find(isNewerDates.High == maxLocalHigh);
                                LocalHighDate = isNewerDates(rowIndex, :);
                                maxRow = LocalHighDate(1, :);
%                                 if isempty(maxHigh)
%                                     maxHigh = NaN;
%                                     maxRow.Date = NaT;
%                                 end
                                disp(maxRow);
                                StatusStopLoss = 0;
                                DateStopLoss = Nat;
                                disp('пока не сработал StoppLoss')
                            else
                                % Сортировка таблицы по столбцу "Date"
                                %                                 sortedTableStop = sortrows(Stoploss, 'Date');
                                %                                 % Получение самой первой строки с данными выше определенного значения
                                %                                 firstRowAboveThresholdStop = sortedTableStop(1, :);
                                %
                                % Используем функцию find для получения индексов строк, соответствующих условию
                                stopIndexRows = find(StopIndex);
                                firstRowAboveThresholdStop = isNewerDates(stopIndexRows(1), :);
                                DateStopLoss = firstRowAboveThresholdStop.Date;
                                disp('данные, когда сработал Stoploss Buy')
                                disp(firstRowAboveThresholdStop);
                                % Используем функцию find для получения индексов строк, соответствующих заданному интервалу
                                dateIndexStoploss = find(isNewerDates.Date >= OpenOrderDateValue & isNewerDates.Date <= firstRowAboveThresholdStop.Date);
                                % Используем полученные индексы для извлечения значений в заданном интервале
                                valuesInInterval = isNewerDates.High(dateIndexStoploss);
                                % Находим максимальное значение в заданном интервале
                                maxHigh = max(valuesInInterval);
                                % Находим индекс строки с максимальным значением в столбце "High"
                                [rowIndex, ~] = find(isNewerDates.High == maxHigh);
                                % Получаем всю строку по найденному индексу
                                maxRow = isNewerDates(rowIndex, :);
                                maxRow = maxRow(1, :);
%                                 if isempty(maxHigh)
%                                     maxHigh = NaN;
%                                     maxRow.Date = NaT;
%                                 end
                                % Теперь в переменной maxRow хранится вся строка с максимальным значением в столбце "High"
                                disp('данные, когда было максимально значение в сторону прогноза до срабатывания стопа или терминэйт')
                                disp(maxRow);
                                StatusStopLoss = 1;
                                disp('сработал StoppLoss')
                            end
                            
                        else
                            disp('значение максимума есть, бумага росла');
                            
                            % Сортировка таблицы по столбцу "Date"
                            sortedTableHigh = sortrows(High, 'Date');
                            % Получение самой первой строки с данными выше определенного значения
                            firstRowAboveThresholdHigh = sortedTableHigh(1, :);
                            disp('данные, когда сработал Takeprofit Buy')
                            disp(firstRowAboveThresholdHigh);
                            
                            % Сортировка таблицы по столбцу "Date"
                            if isempty(Stoploss)
                                StatusStopLoss = 0;
                                DateStopLoss = Nat;
                                disp('значение стопа пусто');
                            else
                                % Сортировка таблицы по столбцу "Date"
                                %                                 sortedTableStop = sortrows(Stoploss, 'Date');
                                %                                 % Получение самой первой строки с данными выше определенного значения
                                %                                 firstRowAboveThresholdStop = sortedTableStop(1, :);
                                
                                % Используем функцию find для получения индексов строк, соответствующих условию
                                stopIndexRows = find(StopIndex);
                                firstRowAboveThresholdStop = isNewerDates(stopIndexRows(1), :);
                                DateStopLoss = firstRowAboveThresholdStop.Date;
                                disp('данные, когда сработал Stoploss Buy')
                                disp(firstRowAboveThresholdStop);
                                % Используем функцию find для получения индексов строк, соответствующих заданному интервалу
                                dateIndexStoploss = find(isNewerDates.Date >= OpenOrderDateValue & isNewerDates.Date <= firstRowAboveThresholdStop.Date);
                                % Используем полученные индексы для извлечения значений в заданном интервале
                                valuesInInterval = isNewerDates.High(dateIndexStoploss);
                                % Находим максимальное значение в заданном интервале
                                maxHigh = max(valuesInInterval);
                                % Находим индекс строки с максимальным значением в столбце "High"
                                [rowIndex, ~] = find(isNewerDates.High == maxHigh);
                                % Получаем всю строку по найденному индексу
                                maxRow = isNewerDates(rowIndex, :);
                                maxRow = maxRow(1, :);
%                                 if isempty(maxHigh)
%                                     maxHigh = NaN;
%                                     maxRow.Date = NaT;
%                                 end
                                % Теперь в переменной maxRow
                                % хранится вся строка с максимальным значением в столбце "High" по ней мы смотрим, когда
                                % был самый максимум перед стоплосом
                                % или сработал ли тэйкпрофит до
                                disp('данные, когда было максимально значение в сторону прогноза до срабатывания стопа или терминэйт')
                                disp(maxRow);
                                
                                if firstRowAboveThresholdStop.Date >= firstRowAboveThresholdHigh.Date
                                    StatusStopLoss = 0;
                                    DateStopLoss = Nat;
                                    TakeProfitStatus = 1;
                                    TakeprofiteDate = firstRowAboveThresholdHigh.Date;
                                    disp('Takeprofit Buy сработал раньше стопа')
                                    disp(IndicatorTakeProfit)
                                else
                                    StatusStopLoss = 1;
                                    IndicatorTakeProfit = NaN;
                                    TakeProfitStatus = 0;
                                    TakeprofiteDate = NaT;
                                    disp('сработал StoppLoss')
                                end
                                
                            end
                        end
                        
                        % Значения, если сделка  открылась
                        
                        TableForecasts{a, 'StatusTakeProfit'} = TakeProfitStatus;
                        TableForecasts{a, 'DateTakeProfit'} = TakeprofiteDate;
                        TableForecasts{a, 'StatusStopLoss'} = StatusStopLoss;
                        TableForecasts{a, 'DateStopLoss'} = DateStopLoss;
                        TableForecasts{a, 'MaxinBuy'} = maxHigh;
                        TableForecasts{a, 'DateMax'} = maxRow.Date;
                        
                    end
                    
                else
                    % Ваш код, который будет выполнен в противном
                    % случае проверяем условие
                    % открытия, чтобы цена открытия не выходили за
                    % пределы стоплоса
                    disp('Сделка Sell:')
                    RuleOpen = isNewerDates{1,'Open'};
                    RuleHigh = isNewerDates{1, 'High'};
                    RuleLow = isNewerDates{1, 'Low'};
                    if BPriceValue > RuleHigh % ищем ГЭП
                        ForecastGap = 1;
                        dateIndexStoploss = find(isNewerDates.Date >= OpenOrderDateValue);
                        % Используем полученные индексы для извлечения значений в заданном интервале
                        valuesInInterval = isNewerDates.Low(dateIndexStoploss);
                        % Находим максимальное значение в заданном интервале
                        maxLow = min(valuesInInterval);
                        % Находим индекс строки с максимальным значением в столбце "Low"
                        [rowIndex, ~] = find(isNewerDates.Low == maxLow);
                        % Получаем всю строку по найденному индексу
                        minRow = isNewerDates(rowIndex, :);
                        minRow = minRow(1, :);
%                         if isempty(maxLow)
%                             maxLow = NaN;
%                             minRow.Date = NaT;
%                         end
                        TableForecasts{a, 'MinSell'} = maxLow;
                        TableForecasts{a, 'DateMin'} = minRow.Date;
                    else
                        ForecastGap = NaN;
                        TableForecasts{a, 'MinSell'} = NaN;
                        TableForecasts{a, 'DateMin'} = NaT;
                        TableForecasts{a, 'MaxinBuy'} = NaN;
                        TableForecasts{a, 'DateMax'} = NaT;
                    end
                    RuleOpenIndex = RuleOpen >= StopLossValue | RuleLow > BPriceValue | BPriceValue > RuleHigh ;
                    if any(RuleOpenIndex)
                        % Хотя бы одно из условий выполнилось
                        StatusOpen = NaN;
                        disp('open price выше стоплосса или(и) не соответствует другим условиям -  сделка не открывается ');
                    else
                        % Ни одно из условий не выполнилось
                        disp('open price не выше stoplossa и максимум не ниже цены входа на сэл ');
                        StatusOpen = 1;
                        LowIndex = isNewerDates.Low <= EffectiveTakeProfitPriceValue & OpenOrderDateValue <= isNewerDates.Date;
                        Low = isNewerDates(LowIndex, :);%тэйк профит
                        StopIndex = isNewerDates.High >= StopLossValue & OpenOrderDateValue <= isNewerDates.Date;
                        Stoploss = isNewerDates(StopIndex, :);
                        if isempty(Low) % Функция isempty возвращает значение true, если таблица пустая, и false, если в таблице есть данные.
                            disp('значение минимума меньше Тэйкпрофита пусто, значит бумага больше не падала и(или) был StopLoss или Terminate');
                            % Сортировка таблицы по столбцу "Date"
                            if isempty(Stoploss)
                                disp('значение стопа пусто');
                                dateIndexStoploss = find(isNewerDates.Date >= OpenOrderDateValue);
                                % Используем полученные индексы для извлечения значений в заданном интервале
                                valuesInInterval = isNewerDates.Low(dateIndexStoploss);
                                % Находим максимальное значение в заданном интервале
                                maxLow = min(valuesInInterval);
                                % Находим индекс строки с максимальным значением в столбце "Low"
                                [rowIndex, ~] = find(isNewerDates.Low == maxLow);
                                % Получаем всю строку по найденному индексу
                                minRow = isNewerDates(rowIndex, :);
                                minRow = minRow(1, :);
%                                 if isempty(maxLow)
%                                     maxLow = NaN;
%                                     minRow.Date = NaT;
%                                 end
                                disp('данные, когда было максимально значение в сторону прогноза по текущую дату')
                                disp(minRow);
                                TakeProfitStatus = 0;
                                StatusStopLoss = 0;
                                DateStopLoss = NaT;
                                IndicatorTakeProfit = NaN;
                                TakeprofiteDate = NaT;
                                disp('позиция еще открыта и получили минимальные занчения после открытия ')
                                
                            else
                                % Сортировка таблицы по столбцу "Date"
                                %                                 sortedTableStop = sortrows(Stoploss, 'Date');
                                %                                 % Получение самой первой строки с данными выше определенного значения
                                %                                 firstRowAboveThresholdStop = sortedTableStop(1, :);
                                
                                % Используем функцию find для получения индексов строк, соответствующих условию
                                stopIndexRows = find(StopIndex);
                                firstRowAboveThresholdStop = isNewerDates(stopIndexRows(1), :);
                                DateStopLoss = firstRowAboveThresholdStop.Date;
                                disp('данные, когда сработал Stoploss Buy')
                                disp(firstRowAboveThresholdStop);
                                % Используем функцию find для получения индексов строк, соответствующих заданному интервалу
                                dateIndexStoploss = find(isNewerDates.Date >= OpenOrderDateValue & isNewerDates.Date <= firstRowAboveThresholdStop.Date);
                                % Используем полученные индексы для извлечения значений в заданном интервале
                                valuesInInterval = isNewerDates.Low(dateIndexStoploss);
                                % Находим максимальное значение в заданном интервале
                                maxLow = min(valuesInInterval);
                                % Находим индекс строки с максимальным значением в столбце "Low"
                                [rowIndex, ~] = find(isNewerDates.Low == maxLow);
                                % Получаем всю строку по найденному индексу
                                minRow = isNewerDates(rowIndex, :);
                                minRow = minRow(1, :);
                                % Теперь в переменной maxRow
                                % хранится вся строка с
                                % максимальным значением в столбце
                                % "Low" по ней мы смотрим, когда
                                % был самый минимум перед стоплосом
                                % или сработал ли тэйкпрофит до
%                                 if isempty(maxLow)
%                                     maxLow = NaN;
%                                     minRow.Date = NaT;
%                                 end
                                disp('данные, когда было максимально значение в сторону прогноза перед срабатывания стопа или терминэйт')
                                disp(minRow);
                                StatusStopLoss = 1;
                                TakeProfitStatus = 0;
                                IndicatorTakeProfit = NaN;
                                TakeprofiteDate = NaT;
                                disp('сработал StoppLoss')
                            end
                            
                        else
                            disp('значение минимума есть, значит бумага падала');
                            % Сортировка таблицы по столбцу "Date"
                            sortedTableLow = sortrows(Low, 'Date');
                            % Получение самой первой строки с данными выше определенного значения
                            firstRowAboveThresholdLow = sortedTableLow(1, :);
                            disp('данные, когда сработал Takeprofit Sell')
                            if isempty(Stoploss)
                                TakeProfitStatus = 1;
                                StatusStopLoss = 0;
                                TakeprofiteDate = firstRowAboveThresholdLow.Date;
                                disp('значение стопа пусто');
                            else
                                % Сортировка таблицы по столбцу "Date"
                                %                                 sortedTableStop = sortrows(Stoploss, 'Date');
                                %                                 % Получение самой первой строки с данными выше определенного значения
                                %                                 firstRowAboveThresholdStop = sortedTableStop(1, :);
                                
                                % Используем функцию find для получения индексов строк, соответствующих условию
                                stopIndexRows = find(StopIndex);
                                firstRowAboveThresholdStop = isNewerDates(stopIndexRows(1), :);
                                DateStopLoss = firstRowAboveThresholdStop.Date;
                                disp('данные, когда сработал Stoploss Sell')
                                disp(firstRowAboveThresholdStop);
                                % Используем функцию find для получения индексов строк, соответствующих заданному интервалу
                                dateIndexStoploss = find(isNewerDates.Date >= OpenOrderDateValue & isNewerDates.Date <= firstRowAboveThresholdStop.Date);
                                % Используем полученные индексы для извлечения значений в заданном интервале
                                valuesInInterval = isNewerDates.Low(dateIndexStoploss);
                                % Находим минимальное значение в заданном интервале
                                maxLow = min(valuesInInterval);
                                % Находим индекс строки с максимальным значением в столбце "Low"
                                [rowIndex, ~] = find(isNewerDates.Low == maxLow);
                                % Получаем всю строку по найденному индексу
                                minRow = isNewerDates(rowIndex, :);
                                minRow = minRow(1, :);
%                                 if isempty(maxLow)
%                                     maxLow = NaN;
%                                     minRow.Date = NaT;
%                                 end
                                % Теперь в переменной maxRow
                                % хранится вся строка с
                                % максимальным значением в столбце
                                % "Low" по ней мы смотрим, когда
                                % был самый минимум перед стоплосом
                                % или сработал ли тэйкпрофит до
                                disp('данные, когда было максимально значение в сторону прогноза до срабатывания стопа или терминэйт')
                                disp(minRow);
                                if firstRowAboveThresholdStop.Date >= firstRowAboveThresholdLow.Date
                                    StatusStopLoss = 0;
                                    TakeProfitStatus = 1;
                                    TakeprofiteDate = firstRowAboveThresholdLow.Date;
                                    StatusStopLoss = 0;
                                    DateStopLoss = Nat;
                                    disp('Takeprofit Sell сработал раньше стопа')
                                    disp(IndicatorTakeProfit)
                                else
                                    StatusStopLoss = 1;
                                    IndicatorTakeProfit = NaN;
                                    TakeProfitStatus = 0;
                                    TakeprofiteDate = NaT;
                                    %                                     MinAfterOpen = 1;
                                    disp('сработал StoppLoss')
                                end
                            end
                            
                        end
                        
                        % Значения, если сделка  открылась
                        
                        TableForecasts{a, 'StatusTakeProfit'} = TakeProfitStatus;
                        TableForecasts{a, 'DateTakeProfit'} = TakeprofiteDate;
                        TableForecasts{a, 'StatusStopLoss'} = StatusStopLoss;
                        TableForecasts{a, 'DateStopLoss'} = DateStopLoss;
                        TableForecasts{a, 'MinSell'} = maxLow;
                        TableForecasts{a, 'DateMin'} = minRow.Date;
                        
                    end
                    
                end
                
                if isnan(TableForecasts.MaxinBuy(a)) && isnan(TableForecasts.MinSell(a)) % Если оба значения в столбцах для строки a равны NaN, то выводим 'ok',
                    Profit_percent = NaN;
                    DaysOfWaiting = NaN;
                    disp('прогноз полностью неверен')
                else
                    if isnan(TableForecasts.MaxinBuy(a))
                        % Расчет процента прибыли
                        %profit_percent = ((price_sell - price_buy) / price_sell) * 100;
                        Profit_percent = ((TableForecasts.BPrice(a) - TableForecasts.MinSell(a)) / TableForecasts.BPrice(a)) * 100;
                        DaysOfWaiting = days(TableForecasts.DateMin(a) - TableForecasts.OpenOrderDate(a));
                    else
                        %profit_percent = ((price_sell - price_buy) / price_buy) * 100;
                        Profit_percent = ((TableForecasts.MaxinBuy(a) - TableForecasts.BPrice(a)) / TableForecasts.BPrice(a)) * 100;
                        DaysOfWaiting = days(TableForecasts.DateMax(a) - TableForecasts.OpenOrderDate(a));
                    end
                    
                    disp('Profit_percent =')
                    disp(Profit_percent)
                    disp('DaysOfWaiting')
                    disp(DaysOfWaiting)
                end
                
                
                % Значения, которые мы берем всегда
                TableForecasts{a, 'StatusOpenOrder'} = StatusOpen;
                TableForecasts{a, 'RuleOpen'} = RuleOpen;
                TableForecasts{a, 'RuleHigh'} = RuleHigh;
                TableForecasts{a, 'RuleLow'} = RuleLow;
                TableForecasts{a, 'ForecastGap'} = ForecastGap;
                TableForecasts{a, 'Profit_percent'} = Profit_percent;
                TableForecasts{a, 'DaysOfWaiting'} = DaysOfWaiting;
                %TableForecasts{a, 'TakeProfitAfterStopValue'} = TakeProfitAfterStopValue;
                
                
                
                a = a + 1;
            end
            
        end
        
    catch err
        disp('Произошла ошибка:');
        disp(err.message);
        % Продолжаем выполнение следующего цикла или другой части кода
    end
    
    try
        % Подсчет количества ячеек со значением 1
        countOfOpenOrders = sum(TableForecasts.StatusOpenOrder == 1);
        countOfGap = sum(TableForecasts.ForecastGap == 1);
        countOfProfit = sum(TableForecasts.StatusTakeProfit == 1);
        countOfStop = sum(TableForecasts.StatusStopLoss == 1);
        countOfOrders = numRowsDates;
        countWithDataMin = sum(~isnat(TableForecasts.DateMin)); % Подсчитываем количество ячеек с данными в столбце (исключая NaT)
        countWithDataMax = sum(~isnat(TableForecasts.DateMax)); % Подсчитываем количество ячеек с данными в столбце (исключая NaT)
        CountDataProfit = countWithDataMin + countWithDataMax;
        CountAverageDaysDataProfit = round(mean(TableForecasts.DaysOfWaiting, 'omitnan'), 0); %исключая значения NaN
        % Находим индексы ячеек с двухзначными числами (исключая NaN и Inf)
        indexTwoDigitValues = isfinite(TableForecasts.DaysOfWaiting) & ~isnan(TableForecasts.DaysOfWaiting) & abs(TableForecasts.DaysOfWaiting) >= 10 & abs(TableForecasts.DaysOfWaiting) < 100;
        % Вычисляем среднее значение только для ячеек с двухзначными числами, исключая значения NaN
        averageValue = round(mean(TableForecasts.DaysOfWaiting(indexTwoDigitValues)), 0);
        CountAveragePercentProfitDataProfit = mean(TableForecasts.Profit_percent, 'omitnan'); %исключая значения NaN
        % Вычисляем индексы строк, для которых значение столбца Profit_percent <= 2
        indexThreePercent = TableForecasts.Profit_percent <= 3;
        % Фильтруем значения столбца DaysOfWaiting по логическому индексу
        ThreePercentDays = TableForecasts.DaysOfWaiting(indexThreePercent);
        ThreePercentDaysAverage = mean(ThreePercentDays);
        
        
        
        % Подсчет процента ячеек со значением 1 от общего числа ячеек в столбце
        %totalCells = numel(myColumn);
        percentageOfProfits = (countOfProfit / countOfOpenOrders) * 100;
        percentageOfStops = (countOfStop / countOfOpenOrders) * 100;
        percentageOfDataProfit = (CountDataProfit / countOfOrders) * 100;
        
        
        
        % Создаем новый столбец с пустыми значениями
        TableForecasts.CountCorrectForecastsDirection = zeros(size(TableForecasts, 1), 1);
        TableForecasts.CountCorrectForecastsDirection(countOfOrders) = CountDataProfit;
        
        TableForecasts.PercentageOfCorrectForecastsDirection = zeros(size(TableForecasts, 1), 1);
        TableForecasts.PercentageOfCorrectForecastsDirection(countOfOrders) = percentageOfDataProfit;
        
        TableForecasts.CountAverageDaysDataProfit = zeros(size(TableForecasts, 1), 1);
        TableForecasts.CountAverageDaysDataProfit(countOfOrders) = CountAverageDaysDataProfit;
        
        TableForecasts.CountAverageDaysDataProfitlow100d = zeros(size(TableForecasts, 1), 1);
        TableForecasts.CountAverageDaysDataProfitlow100d(countOfOrders) = averageValue;
        
        TableForecasts.ThreePercentDaysAverage = zeros(size(TableForecasts, 1), 1);
        TableForecasts.ThreePercentDaysAverage(countOfOrders) = ThreePercentDaysAverage;
        
        TableForecasts.CountAveragePercentProfitDataProfit = zeros(size(TableForecasts, 1), 1);
        TableForecasts.CountAveragePercentProfitDataProfit(countOfOrders) = CountAveragePercentProfitDataProfit;
        
        TableForecasts.PercentageOfTakeProfits = zeros(size(TableForecasts, 1), 1);
        TableForecasts.PercentageOfTakeProfits(countOfOrders) = percentageOfProfits;
        
        TableForecasts.PercentageOfStopLoss = zeros(size(TableForecasts, 1), 1);
        TableForecasts.PercentageOfStopLoss(countOfOrders) = percentageOfStops;
        
        
        %         % Указываем имя файла, в который будем экспортировать данные
        %         file_name = 'exported_data_test_sp500.csv';
        %
        %         % Используем функцию writetable для экспорта таблицы в CSV-файл
        %         writetable(TableForecasts, file_name);
        
        
        
        
        disp(['Количество ордеров: ', num2str(countOfOrders)]);
        disp(['Количество открытых ордеров: ', num2str(countOfOpenOrders)]);
        disp(['Количество gap в сторону прогноза: ', num2str(countOfGap)]);
        disp(['Количество верных прогнозов по направлению: ', num2str(CountDataProfit)]);
        disp(['Процент верных прогнозов по направлению: ', num2str(percentageOfDataProfit), ' %']);
        disp(['Процент доходности средний: ', num2str(CountAveragePercentProfitDataProfit), ' %']);
        disp(['Количество тэйкпрофит: ', num2str(countOfProfit)]);
        disp(['Процент жестких тэйкпрофитов: ', num2str(percentageOfProfits), ' %']);
        disp(['Количество стопов: ', num2str(countOfStop)]);
        disp(['Процент жестких стопов: ', num2str(percentageOfStops), ' %']);
    catch error
        disp('Произошла ошибка:');
        disp(error.message);
        % Продолжаем выполнение следующего цикла или другой части кода
    end
    
    i = i + 1;
    
    k = 2;
    pause(k)
end
